name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    name: Test
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-14, windows-2022]
        go-version: [1.22, 1.23]
    
    steps:
    - name: Check out code
      uses: actions/checkout@v4
      
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ matrix.go-version }}
        
    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/go/pkg/mod
          ~/.cache/go-build
        key: ${{ runner.os }}-go-${{ matrix.go-version }}-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-${{ matrix.go-version }}-
          ${{ runner.os }}-go-
      continue-on-error: true  # Don't fail if cache operations have issues
          
    - name: Download dependencies
      run: go mod download
      
    - name: Verify dependencies
      run: go mod verify
      
    - name: Run go vet
      run: |
        echo "🔍 Running go vet on ${{ matrix.os }} with Go ${{ matrix.go-version }}"
        go vet ./...
        echo "✅ go vet completed successfully"
      shell: bash
      
    - name: Run go fmt check
      run: |
        # Normalize line endings on Windows to prevent false positives
        if [[ "${{ matrix.os }}" == windows-* ]]; then
          echo "Running on Windows - normalizing line endings"
          # Install dos2unix if not available
          if command -v apt-get &> /dev/null; then
            sudo apt-get update && sudo apt-get install -y dos2unix
          elif command -v pacman &> /dev/null; then
            sudo pacman -S --noconfirm dos2unix
          fi
          # Convert all Go files to Unix line endings
          find . -name "*.go" -type f -exec dos2unix {} \; 2>/dev/null || {
            echo "dos2unix not available, using sed fallback"
            find . -name "*.go" -type f -exec sed -i 's/\r$//' {} \;
          }
        fi
        
        # Check formatting
        UNFORMATTED=$(gofmt -s -l . 2>/dev/null || echo "")
        if [ ! -z "$UNFORMATTED" ]; then
          echo "Code is not formatted. Run 'go fmt ./...'"
          echo "Unformatted files:"
          echo "$UNFORMATTED"
          exit 1
        else
          echo "✅ All Go files are properly formatted"
        fi
      shell: bash
      
    - name: Run tests with conditional coverage
      run: |
        if [[ "${{ matrix.os }}" == "ubuntu-latest" && "${{ matrix.go-version }}" == "1.23" ]]; then
          go test -v -race -timeout=30s -coverprofile=coverage.out -json ./... > test-results.json
        else
          go test -v -race -timeout=30s -json ./... > test-results.json
        fi
      shell: bash
    
    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results-${{ matrix.os }}-go${{ matrix.go-version }}
        path: test-results.json
      
    - name: Display coverage summary
      if: matrix.os == 'ubuntu-latest' && matrix.go-version == '1.23'
      run: |
        if [ -f coverage.out ]; then
          echo "📊 Coverage Report Generated"
          go tool cover -func=coverage.out | tail -1
          echo "Coverage file size: $(wc -c < coverage.out) bytes"
        else
          echo "⚠️ No coverage file found"
        fi
      shell: bash
    
    - name: Upload coverage to Codecov
      if: matrix.os == 'ubuntu-latest' && matrix.go-version == '1.23'
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage.out
        token: ${{ secrets.CODECOV_TOKEN }}
        fail_ci_if_error: false  # Don't fail CI if Codecov upload fails
        verbose: true
      continue-on-error: true  # Allow workflow to continue if Codecov is unavailable

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - name: Check out code
      uses: actions/checkout@v4
      
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: 1.23
        
    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/go/pkg/mod
          ~/.cache/go-build
        key: ${{ runner.os }}-go-1.23-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-1.23-
          
    - name: Build application
      run: make build
      
    - name: Test build and smoke tests
      run: |
        echo "Testing binary execution..."
        ./build/netwatch --help
        
        echo "Testing version command..."
        ./build/netwatch --version || echo "Version command not available"
        
        echo "Testing configuration validation..."
        ./build/netwatch --validate-config || echo "Config validation not available"
        
        echo "Basic smoke test completed successfully"
      shell: bash
        
    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
        name: netwatch-${{ runner.os }}-${{ github.sha }}
        path: build/netwatch

  lint:
    name: Lint
    runs-on: ubuntu-latest
    
    steps:
    - name: Check out code
      uses: actions/checkout@v4
      
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: 1.23
        
    - name: Run golangci-lint
      uses: golangci/golangci-lint-action@v4
      with:
        version: latest
        args: --timeout=5m

  integration:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - name: Check out code
      uses: actions/checkout@v4
      
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: 1.23
        
    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/go/pkg/mod
          ~/.cache/go-build
        key: ${{ runner.os }}-go-1.23-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-1.23-
          
    - name: Build application
      run: make build
      
    - name: Run integration tests
      run: make test-integration